# 1장 오브젝트와 의존관계

## #Spring/toby/오브젝트와의존관계

# 스프링의 핵심

- 스프링의 핵심을 담당하는건 바로 빈 팩토리 또는 애플리케이션 컨텍스트라고 불리는것이다.
- 스프링은 태생적으로 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버환경에서 사용될 때 그 가치가 있다.
- 스프링이 개발자에게 제공하는 가장 중요한 가치는 객체지향과 테스트이다.

---

# 애플리케이션 컨텍스트와 설정정보

## 빈 팩토리

- 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부른다.
- 애플리케이션 컨텍스트의 최상위 부모
- 이 인터페이스에 `getBean()`과 같은 메소드가 정의되어 있다.

---

## 애플리케이션 컨텍스트(ApplicationContext)

- 빈 팩토리를 좀더 확장한 개념(추가적인 기능 제공)
- 애플리케이션은 애플리케이션 컨텍스트와 그 설정정보를 따라서 만들어지고 구성된다.
- 애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성 관계설정등의 제어작업을 총괄한다.
- 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.
- 스프링 컨테이너는 싱글톤을 생성하고, 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다. -> 싱글톤 레지스트리
- 애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다.
- `getBean()`
  - `getBean()`메소드는 기본 `Object`타입으로 리턴하게 되어 있어서 매번 리턴되는 오브젝트에 다시 캐스팅 해줘야 하는 부담이 있으나, 타입을 같이 지정해줄시 자바의 제네릭을 사용하여 지정된 타입으로 반환해준다.
  - `getBean("빈이름", 빈타입.class)` : Dependency Lookup에 사용
  - `ApplicationContext`가 관리하는 오브젝트를 요청하는 메소드다.

```java
// 스프링 적용
ApplicationContext ac =
	new AnnotationConfigApplicationContext(DaoFactory.class);
UserDao dao = ac.getBean("userDao", UserDao.class);
```

### 애플리케이션 컨텍스트의 동작방식

[image:EF676FC4-99E5-4A89-8334-06F3967B06DB-34828-00000FE79C680F0E/Screen Shot 2022-03-11 at 15.05.03.png]

### 애플리케이션 컨텍스트를 사용했을때 얻을 수 있는 장점

- 클라이언트틑 구체적인 팩토리 클래스를 알 필요가 없다.
- 애플리케이션 컥텍스트는 종합 IoC 서비스를 제공해준다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
- 싱글톤을 보장

---

## `@Configuration`

- 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식하게 해주는 애노테이션
- `@Configuration`이 붙은 자바코드를 설정정보로 사용하려면 `AnnotationConfigApplicationContext`를 이용하면 된다.
- 스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다.

---

## `@Bean`

- 오브젝트를 만들어주는 메소드
  > _참고 : 빈_
  > 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(Bean)이라고 부른다. 오브젝트 단위의 애플리케이션 컴포넌트를 말한다. 동시에 스프링빈은 스프링 컨테이너가 생성과 관계설정, 사용등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.

---

# XML을 이용한 설정

- XML 설정은 `@Configuration`과 `@Bean`이 붙은 자바 클래스로 만든 설정과 내용이 동일하다.
- `@Configuration`을 `<beans>`, `@Bean`을 `<bean>` 에 대응해서 생각하면된다.
- `id` : 메소드 이름
- `class` : 반환타입이아니라 반환할때 생성하는 오브젝트
- 자바빈의 관례를 따라서 수정자 메소드는 프로퍼티가 된다. 프로퍼티 이름은 메소드 이름에서 set을 제외한 나머지 부분을 사용한다.
  - `setConnectionMaker() -> connectionMaker`
- `property` : 오브젝트가 가지고있는 프로퍼티 설정
  - `name` : 프로퍼티 이름
  - `ref` : 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름, 즉 주입할 오브젝트를 정의한 <bean>의 ID

```xml
<bean id="userDao" class="user.dao.UserDao">
    <property name="connectionMaker" ref="connectionMaker" />
</bean>
```

- `value` : 텍스트나 단순 오브젝트등을 수정자 메소드에 넣어주는 것을 스프링에서는 값을 주입한다고 말한다. `value` 는 값을 주입할때 사용

```xml
<bean id="dataSource"
		class="org.springframework.jdbc.datasource.
									SimpleDriverDataSource">
    <property name="driverClass"
					 value="com.mysql.cj.jdbc.Driver" />
    <property name="url"
			value="jdbc:mysql://localhost/tobyspring" />
    <property name="username" value="root" />
    <property name="password" value="00000000" />
</bean>
```

- 수정자주입을 하는 이유

```java
@Bean
public UserDao userDao() {
        // 수정자 주입을 통한 연관관계 설정
        // xml파일에 프로퍼티설정이 용이하다.
        UserDao userDao = new UserDao();
        userDao.setConnectionMaker(connectionMaker());
        return userDao;
}
```

- 설정정보 사용시의 애플리케이션 컨텍스트

```java
// 자바 코드를 이용한 설정정보 사용
ApplicationContext ac =
	new AnnotationConfigApplicationContext(DaoFactory.class);
// xml 파일을 이용한 설정정보 사용
ApplicationContext ac =
	new GenericXmlApplicationContext("applicationContext.xml");
```

---

# 스프링 빈의 스코프

- 빈이 생성되고 존재하고 정욕되는 범위
- 스프링빈의 기본 스코프는 싱글톤
- 싱글톤 스코프는 컨테이너 내에 한개의 오브젝트만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.
- 싱글톤 스코프, 프로토타입 스코프, request 스코프, 세션 스코프등이 존재

---

> _참고 : DAO_
> Data Access Object는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

> _참고 : 자바빈이란?_ > *디폴트 생성자:*자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
> _프로퍼티:_ 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

> _참고 : 리팩토링 (Refactoring)_
> 리팩토링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 결국 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다. 리팩토링이 절실히 필요한 코드의 특징을 나쁜 냄새라고 부르기도 한다. 대표적으로, 중복된 코드는 매우 흔하게 발견되는 나쁜 냄새다. 이런 코드는 적절한 리팩토링 방법을 적용해 나쁜 냄새를 제거해줘야 한다.
> 리팩토링은 개발자가 직관적으로 수행할 수 있긴 하지만, 본격적으로 적용하자면 학습과 훈련이 필요하 다. 나쁜 냄새에는 어떤 종류가 있고, 그에 따른 적절한 리팩토링 방법은 무엇인지 알아보고, 충분한 연습을 해두면 도움이 된다.

# 책 에서 설명하는 JDBC를 이용한 작업 순서

• DB 연결을 위한 `Connection` 을 가져온다.
• SQL을 담은 `Statement` (또는 `PreparedStatement`) 를 만든다.
• 만들어진 `Statement` 를 실행한다.
• 조회의 경우 SQL 쿼리의 실행 결과를 `ResultSet` 으로 받아서 정보를 저장할 오브젝트 (여기서는 User) 에 옮겨준다.
• 작업 중에 생성된 `Connection` , `Statement` , `ResultSet` 같은 리소스는 작업을 마친 후 반드시 닫아준다.
• JDBC API가 만들어내는 예외 `exception` 를 잡아서 직접 처리하거나, 메소드에 `throws`를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.

# 관심사의 분리(Separation Of Concerns)

- 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.
- 객체지향 기술 -> 변화에 효과적으로 대철할수 있다.
  - 변화에 가장 좋은 대책은 변화의 폭을 최소한으로 줄여주는것.
  - 분리와 확장을 고려한 설계가 필요하다.
    - 관심사의 분리
- 객체지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있다고 여겨진다. 하지만 그보다는 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는 데 더 의미가 있다.
  > _참고 : 관심사의 분리_
  > 관심사의 분리(SoC)는 소프트웨어 개발에서 가장 기본적인 원칙 중 하나이며, SOLID 원칙 5개 중 2개(단일 책임 및 인터페이스 분리)가 이 개념에서 직접 파생될 정도로 매우 중요합니다.
  > 원칙은 간단. 프로그램을 하나의 단일 블록으로 작성하지 말고 작은 조각으로 나누어 각각 간단한 개별 작업을 완료할 수 있도록 만드는 것이다. 하나의 함수가 방대해지고 여러가지 작업을 수행한다면 분리해야될 신호로 볼 수 있다.

---

# 템플릿 메소드 패턴

- 슈퍼클래스에 기본적인 로직의 흐름 (커넥션 가져오기, SQL 생성, 실행, 반환) 을 만들고, 그기능의 일부를 추상 메소드나 오버라이딩이 가능한 `protected` 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴 에서 템플릿 메소드 패턴 template method pattern 이라고 한다.

---

# 팩토리 메소드 패턴

## [[Factory Method Pattern]]

# 전략 패턴(Strategy Pattern)

## [[Strategy Pattern]]

# 싱글톤 패턴(Singleton Pattern)

- 싱글톤 패턴은 GoF가 소개한 디자인 패턴 중의 하나다. 디자인 패턴 중에서 가장 자주 활용되는 패턴 이기도 하지만 가장 많은 비판을 받는 패턴이기도 하다. 심지어 디자인 책을 쓴 GoF 멤버조차도 싱글톤 패턴은 매우 조심해서 사용해야 하거나 피해야 할 패턴이라고 말하기도 한다. 싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. 이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능하다. 단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다.
- 싱글톤은 무상태(stateless)로 설계되어야 한다.

## 싱글톤 패턴의 문제점

- `private` 생성자를 갖고있기 때문에 상속할 수 없다.
  - `private`생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능하다
  - 그로 인해 객체지향의 장점인 상속과 이를 이용한 다형성을 적용 할 수 없다.
- 싱글톤은 테스트하기 힘들다.
  - 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다.
- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
- 싱글톤의 사용은 전역 상태(global state)를 만들 수 있기 때문에 바람직하지 못하다.
  - 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.

---

# SOLID

## 개방 폐쇄 원칙(OCP)

- 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다
- 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 소프트웨어 개발의 고전적인 원리로도 설명이 가능.

### 높은 응집도

- 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것을 의미할 수도 있다.

### 낮은 결합도

- 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
- 느슨한 연결은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고 나머지는 서로 독립적이고 알 필요도 없게 만들어주는것이다.
- 결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다.
- 확장하기에도 매우 편리하다.
- 여기서 말하는 결합도란 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고있는 다른 오브젝트에게 변화를 요구하는 정도라고 설명할 수 있다.

---

# 제어의 역전(IoC)

- 제어의 역전이라는건, 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명 할 수 있다.
- 일반적인 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 모든 종류의 작업을 사용하는 쪽에서 제어하고 관장하는 구조이다.
- 제어의 역전에서는 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하고, 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어 진다.
- 대표적으로 서블릿이나 JSP, EJB가 제어의 역전이 적용된 예다.
- 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 고나리등을 관장하는 존재가 필요하다. 여기서는 `DaoFactory`가 `IoC` 컨테이너라고 불릴수있다.
  [image:734FEF02-FEBB-48EF-8F09-4DBB025A8C02-34828-00000FD8107F3CFD/Screen Shot 2022-03-11 at 14.18.42.png]

---

# 기타

## 상속의 한계점

- 자바는 클래스의 다중상속을 허용하지 않는다.
- 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다
  - 서브 클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다. 그래서 슈퍼 클래스 내부의 변경이 있을때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도있다.

---

## 인터페이스

- 두개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는것
- 인터페이스는 어떤일을 하겠다는 기능만 정의해놓은것
  - 인터페이스를 구현한 클래스에서는 그 기능에만 관심을 가지면된다. 기능을 어떻게 구현했는지에는 괌심을 둘 필요가 없다.

> _참고 : 추상화란_
> 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업

[image:7C55CACB-4C79-4D54-A20E-D69C86C3A0E7-34828-00000BB0BFAB0DB6/Screen Shot 2022-03-07 at 15.29.12.png]

- 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다.
- 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.

---

## 추상클래스

---

## 오브젝트

- 오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.
  - `connectionMaker = new DConnectionMaker();` -> 사용이라는 관계

---

## 팩토리

- 객체의 생성방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는일을 하는 오브젝트를 팩토리(factory)라고 부른다.
- 오브젝트를 생성하는쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용하는것

> _참고_
> 디자인 패턴에서 말하는 특별한 문제를 해결하기 위해 사용되는 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르니 혼동하지 말것.

---

## 프레임워크

- 프레임워크는 라이브러리의 다른 이름이 아니다. 프레임워크는 단지 미리 만들어둔 반제품이나, 확장해서 사용 할 수 있도록 준비된 추상 라이브러리의 집합이 아니다.
- 애플리케이션의 코드가 프레임워크에 의해 사용된다.
- 프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 프레임워크라고 부를수 있다.
- 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.

---

## 라이브러리

- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.

---

## 오브젝트의 동일성과 동등성

자바에서 두 개의 오브젝트가 같은거라는 말은 주의해서 써야 한다. 자바에서는 두 개의 오브젝트가 완전히 같은 동일한(`identical`) 오브젝트라고 말하는 것과, 동일한 정보를 담고 있는(`equivalent`) 오브젝트라고 말하는 것은 분명한 차이가 있다. 전자는 동일성(`identity`) 비교라고 하고, 후자를 동등성 (`equality`) 비교라고 한다. 동일성은 `==` 연산자로, 동등성은 `equals()` 메소드를 이용해 비교한다.
두 개의 오브젝트가 *동일*하다면 *사실은 하나의 오브젝트만 존재하는 것*이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다. 두 개의 오브젝트가 동일하지는 않지만 *동등한 경우*에는 *두 개의 각기 다른 오브젝트가 메모리상에 존재*하는 것인데, 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다. 물론 동일한 오브젝트는 동등하기도 할 것이다. 하지만 그 반대는 항상 참은 아니다.
자바 클래스를 만들 때 `equals()` 메소드를 따로 구현하지 않았다면, 최상위 클래스인 `Object` 클래스에 구현되어 있는 `equals()` 메소드가 사용된다. `Object`의 `equals()` 메소드는 두 오브젝트의 동일성을 비교해서 그 결과를 돌려준다. 따라서 이때는 동일한 오브젝트여야지만 동등한 오브젝트라고 여겨질 것이다.

---

## 의존관계

- 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다.
- 의존한다는건 의존대상, 여기서는 B가 변하면 그것이 A에 영향을 미친다는 뜻.
- 반대로 B는 A에 의존하지 않는다, 즉 A의 변경이 B에 영향을 주지 않는다.
- A가 B에 의존하고있음을 보여주는 UML
  [image:B85D4EAC-AFC7-48A3-9248-1B144665547D-34828-000010151BD0EBF1/Screen Shot 2022-03-11 at 17.53.36.png]

```java
class A {
	B b = new B();
	b.methodA(); // 사용에 대한 의존관계
}
```

### 의존관계 주입 (Dependency Injection)

- 의존관계 주입이란 다음과 같은 세가지 조건을 충족하는 작업을 말한다.
  1.  클래스 모델이나 코드에는 런타임 시점의 의존관계가 들어나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
  2.  런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
  3.  의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.
- 의존관계 주입의 핵심은 설계시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의존재가 있다는것이다.

---

## DataSource 인터페이스

- DB커넥션을 가져오는 오브젝트의 기능을 추상화해서 비슷한 용도로 사용할 수 있게 만들어진 DataSource라는 인터페이스가 존재한다.

---

> _참고 : 의존 오브젝트_
> 프로그램이 시작되고 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 의존 오브젝트(dependency object)라고 말한다.
