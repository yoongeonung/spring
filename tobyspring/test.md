# 2장 테스트

---

- 테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다. 또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다.
- 테스트는 자동으로 수행되도록 코드로 만들어지는것이 중요하다.
  - 자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는것이다.
- 테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는것.
- 항상 네거티브 테스트를 먼저 만들어야 한다.
- 테스트는 필요하다면 얼마든지 애플리케이션 클래스와 밀접한 관계를 맺고 있어도 상관없다.
- 테스트는 항상 스프링 컨테이너 없이 테스트 할 수 있는 방법을 가장 우선적으로 고려해야한다.
- 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.

---

# 단위 테스트 unit test

- 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는것이 바람직하다.
- 한꺼번에 너무 많은것을 몰아서 테스트하면 테스트 수행과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다.
- 테스트는 가능하면 작은단위로 쪼개서 집중해서 할 수 있어야 한다.
- 이렇게 작은 단위의 코드에 대해 테스트를 수행하는 것을 단위테스트(unit test)라고한다.
- 단위테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다.

## 단위

- 여기서 말하는 단위란 무엇인지, 그 크기와 범위가 어느정도인지 딱 정해진 건 아니다.
- 충분히 하나의 *관심*에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.
- 일반적으로 단위는 작을수록 좋다.

## 단위테스트를 하는 이유

- 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인 받기 위해서다.
- 이때 확인의 대상과 조건이 간단하고 명확할수록 좋다.

---

# 테스트 프레임워크

- _JUnit_
  - JUnit은 프레임워크다.
  - 자바로 단위 테스트를 만들때 유용하게 쓸 수 있다.
  - 스프링과 함께가 아니라 JUnit단독 테스트의 경우 애플리케이션 컨텍스트가 매 테스트마다 생성된다.

---

# 작성 방법

- gradle프로젝트 기준 `…/main/test/`에 위치해야한다.
- `@Test`애노테이션을 이용하여 테스트용 메소드임을 JUnit에게 알려준다.
- 메소드의 접근자는 junit4에서는 반드시 `public`이어야 했으나 junit5부터는 `public`이지 않아도 된다.

```java
@Test
void addAndGet() {
    ApplicationContext ac = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = ac.getBean("userDao", UserDao.class);
}
```

---

### assertThat & matcher를 이용한 테스트

- `assertThat(actual)` 를 이용한 테스트

```java
dao.deleteAll();
assertThat(dao.getCount()).isEqualTo(0);
```

---

### 예외 상황에 대한 테스트

- `assertThrows()` 를 이용한 테스트

```java
assertThrows(EmptyResultDataAccessException.class,
								() -> dao.get("unknown_id"));
```

---

### 확장 기능

- 클래스 내에 하나의 애플리케이션 컨텍스트를 만들어서 공유하는 방법

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = {DaoFactory.class})
class UserDaoTest {

  @Autowired
  private ApplicationContext ac;
	...
}
```

    * `@ExtendWith`  -> JUnit5, (`@RunWith` -> JUnit4)
    	* `@ExtendWith(SpringExtension.class)`
    		* Junit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.
    * `@ContextConfiguration(classes = {DaoFactory.class})`
    	* 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치(location) 혹은 클래스(classes)를 지정
    * 스프링 테스트 컨텍스트 프레임워크를 적용했다면 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는것이 원칙이다.

- 여러개의 테스트 클래스에서 같은 설정파일의 애플리케이션 컨텍스트를 공유하는 방법

```java
// 세 클래스 모두 DaoFactory.class 설정 파일을 지정
// DaoFactory.class 설정파일의 애플리케이션 컨텍스트 하나만 만들어서 공유

@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = {DaoFactory.class})
class UserDaoTest { ... }

@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = {DaoFactory.class})
class MemberDaoTest { ... }

@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = {DaoFactory.class})
class VipDaoTest { ... }
```

- `@DirtiesContext`
  - 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는것을 테스트 컨텍스트 프레임워크에 알려준다.
  - 이 애노테이션이 붙어있으면 스프링 테스트 컨텍스트 프레임워크는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 해당 테스트에서 사용된 애플리케이션 컨텍스트는 패기되고 새로운 애플리케이션 컨텍스트가 만들어져 후의 테스드 메소드에서 사용된다.

---

# 동작 방법

[image:04A893A1-AF64-4D35-9B9F-3F2FC0C768EB-34828-000010EA061B0597/Screen Shot 2022-03-12 at 15.50.50.png]

1. `@Test`가 붙어있고 반환형이 `void`이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
   - 각 테스트 메소드를 실행할 때 마다 테스트 클래스의 오브젝트를 새로만든다. 테스트 메소드가 5개라면 5번 생성한다.
   - 이렇게 새로 만드는 이유는 각 테스트의 독립적으로 실행됨을 확실히 보장해주기 위해서 이다. 덕분에 인스턴스 변수도 부담없이 사용할 수 있다. 어차피 다음 테스트 메소드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화될것이기 때문이다.
3. `@BeforeEach` 애노테이션이 붙은 메소드가 있으면 실행한다.
4. `@Test` 애노테이션이 붙은 메소드를 하나 호출하고 결과를 저장해둔다.
5. `@AfterEach` 애노테이션이 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에대해 2~5을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

---

# 테스트 코드 개선

- 테스트 코드 도 언제든지 내부구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 코드로 만들 필요가 있다.

---

## JUnit에서 제공하는 중복코드 제거방법

- `@BeforeEach`
  - JUnit4에서는 `@Before`
  - `@Test` 가 붙은 메소드에서 직접 호출하지 않기 때문에 서로 주고받을 정보나 오브젝트가 있다면 인스턴스 변수를 이용해야 한다.

```java
private UserDao dao; // 공유용 인스턴스 변수, 픽스쳐(fixture)

@BeforeEach
void beforeEach() {
  final ApplicationContext ac =
	new AnnotationConfigApplicationContext(DaoFactory.class);
  this.dao = ac.getBean("userDao", UserDao.class);
}
```

## 픽스쳐 (fixture)

- 테스트를 수행하는데 필요한 정보나 오브젝트를 픽스쳐라고 한다.
- 일반적으로 픽스쳐는 여러 테스트에서 반복적으로 사용되기 때문에 @BeforeEach 등일 이용해서 생성해두면 편리하다. -> 위 코드의 `dao`가 대표적인 픽스쳐

---

# 테스트 주도 개발 ( Test Driven Development )

- 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도 개발이라고 한다.
- 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 기본원칙
- TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한한 짧게 가져가도록 권장한다.

---

# @Autowired

- 스프링의 DI에 사용되는 특별한 애노테이션이다.

---

# 학습 테스트 (Learning Test)

- 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용방법을 익히는것이 학습테스트의 목적이다.
- 학습 테스트는 테스트 대상보다는 테스트 코드 자체에 관심을 갖고 만들어야 한다.

---

## 학습 테스트의 장점

- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
- 학습 테스트 코드를 개발중에 참고할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
- 테스트 작성에 대한 좋은 훈련이 된다.
- 새로운 기술을 공부하는 과정이 즐거워진다.

---

# 스프링 테스트 컨텍스트

- JUnit과 반대로 스프링의 테스트용 애플리케이션 컨텍스트는 테스트 개수에 상관없이 한 개만 만들어진다.

---

# 버그테스트

- 코드에 오류가 있을때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다.
- 버그테스트는 일단 실패하도록 만들어야 한다. 그 후 버그테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다. 테스트가 성공하면 버그가 해결된것이다.

## 버그테스트의 장점

- 테스트의 완성도를 높여준다
- 버그의 내용을 명확하게 분석하게 해준다.
  - 버그가 있을때 그것을 테스트로 만들어서 실패하게 하려면 어떤 이유때문에 문제가 생겼는지 명확히 알아야 한다.
- 기술적인 문제를 해결하는 데 도움이 된다.

---

> _참고 : 동등 분할_
> 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트를 하는 방법을 말한다. 어떤 작업의 결과의 종류가 true, false 또는 예외발생 세 가지라면 각 결과를 내는 입력 값이나 상황의 조합을 만들어 모든 경우에 대한 테스트를 해보는 것이 좋다.

> _참고 : 경계값 분석_
> 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법이다. 보통 숫자의 입력 값인 경우 0이나 그 주변 값 또는 정수의 최대값, 최소값 등으로 테스트해보면 도움이 될 때가 많다.

---
